
== 6LoWPANのAPI


本稿で紹介したように、ペイロードのサイズの差こそあれ、
6LoWPANはIPv6のデータ構造とほぼ同様の情報を格納している。
このため、intikiでの実装は、@<b>{Arduino標準のTCP/UDP実装と同様} に扱えるAPIとなっている。
(完全互換ではない)
Arduino元々のTCP/UDPのAPIは WIZnet W5100というハードウェア側で通信スタックを持った
チップを使うためのAPIとして実装されている。このため、多少ハードの@<b>{癖}が見えている
APIになっている部分もあるのだが、総じて言えば適切なハード抽象化層となっている。
そのため、ContikiのネットワークAPIとも乖離は少なく、ほぼ「土管」レベルの
受け渡しの実装である。


=== IPAddress


Arduino の IPAddress はIPv4 のデータ構造に合わせた構造となっており、
32bitのIPアドレスを保持するクラスとなっている。
IPv6のアドレスは128bitで、これにあわせてAPIの拡張を行っている。



オリジナルの実装では32bitの指定を行うコンストラクタだったが、
128bitのv6アドレスを指定するため、以下のようなコンストラクタを追加している。


//emlist{
IPAddress::IPAddress(uint16_t d0, uint16_t d1, uint16_t d2, uint16_t d3,
                        uint16_t d4, uint16_t d5, uint16_t d6, uint16_t d7)
//}


@<tt>{bool fromString(const char *address)} や @<tt>{bool operator==(const uint8_t* addr)} は
文字列の表記方法の違いや比較するデータ長の違いから、内部的には
全く別の実装ではあるが、意味としては同等となるよう実装されている。



つまり、IPv6に対して "192.168.1.1"の文字列は、[192, 168, 1, 1]の4バイトではなく、
V6-mapped-V4な ::FFFF:192.168.1.1 として扱われるなど、
関数インターフェース自体は互換であるが、挙動はIPv6に合わせた別の実装となる。


=== Client, Server


TCP通信を行う、 @<tt>{Client}と@<tt>{Server}については、継承元クラスの定義には変更はない。
v6化に伴う変更はIPAddressのクラス構造に閉じており、Client.h,Server.hで定義している
インターフェース(仮想関数)の挙動に意味的な変更はない。
これは、6LoWPANであってもTCPはストリームとして通信が抽象化されているため、
ネットワーク層以下での通信の挙動には関知しないという、TCP自体の設計が反映されている
ということである。
逆説的には、低電力ネットワーク固有の事情などは考慮されていないとも言えるわけで、
消費電力などに特に制約がなければ、従来のTCPのアプリケーションに近い設計を
持ち込める、という程度に理解したほうが良いであろう。


=== UDP


UDPも、API自体はオリジナルのArduinoを踏襲している。すなわち、プログラム言語的な
意味でのインターフェースに変更はない。
実装自体も、多少のバッファリングを行うにせよ、contikiのプロトコルスタックに
中継するという単純な実装となっている。
ただし、UDPの場合は6LoWPANのパケット分割が露骨に見える通信となる。
すなわち、ちょっと大きめのデータを送信すると、送信側では1回の送信を意識したものでも、
6LoWPANのレイヤでパケットが分割され、受信側では2回の受信が行われているようである。
(検証中)
UDPはTCPと比較して、802.15.4の通信に近い(すなわち、ACKなしの投げっぱなし)構造で、
通信時間をコントロールしやすい。
これを活かすために、パケット分割を発生させないよう(下位レイヤを意識しながら)送信データ量を
制御する必要があると言えよう。

